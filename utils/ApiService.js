const moment = require("moment/moment");
const {ButtonBuilder, ButtonStyle, ActionRowBuilder} = require("discord.js");
const axios = require("axios");
const { apiKey, baseApi, maxSizeMessage, nvdLimitItems } = require('../config.json');

function ApiService() {}

const config = {
    headers: {
        apiKey: apiKey
    }
};

function shorten(str, maxLen, separator = ' ') {
    if (str.length <= maxLen) return str;
    return str.substring(0, str.lastIndexOf(separator, maxLen));
}

function isEmpty(obj) {
    for (var key in obj) {
        if (obj[key] !== null && obj[key] != "")
            return false;
    }
    return true;
}

ApiService.prototype.getLatestCVEs = async function() {

    const today = moment(new Date()).format("YYYY-MM-DDT00:00:00");
    const now = moment(new Date()).format("YYYY-MM-DDT23:59:59");

    const response = await axios.get(baseApi + '?pubStartDate=' + today + '&pubEndDate=' + now + '&resultsPerPage=20&StartIndex=0', config)
        .then((response) => {
            let vulnerabilities = response.data.vulnerabilities;

            // Sorting of object by published date of vulnerability, and slice by 3 elements
            vulnerabilities = vulnerabilities.sort((a,b)=>
                a.published > b.published ? 1:-1
            ).sort((a,b)=> {
                if (a.published === b.published) {
                    return a.published - b.published;
                }
            }).slice(0,3);

            //Format the response of the discord bot
            let botResponse = '';
            for (const vulnerability of vulnerabilities) {
                botResponse += "ðŸ”“ **" + vulnerability.cve.id + '**\n';
                botResponse += "Fecha: " + moment(vulnerability.cve.published).format('DD-MM-YYYY HH:mm:ss') + "\n\n";
                let description = vulnerability.cve.descriptions[1] != undefined ?
                    vulnerability.cve.descriptions[1].value + "\n\n" : vulnerability.cve.descriptions[0].value + "\n\n";

                if (description.length > 500) {
                    description = shorten(description, 500) + '... \n\n';
                }
                botResponse += description;
            }

            if (vulnerabilities.length == 0) {
                botResponse += "No hay CVEs nuevos en el dÃ­a de hoy.";
            }

            if (botResponse.length > maxSizeMessage) {
                botResponse = shorten(botResponse, maxSizeMessage - 3) + '...';
            }

            return {
                content: botResponse
            };
        });
    return response;
};

ApiService.prototype.getCVE = async function(id) {
    const response = await axios.get(baseApi + '?cveId=' + id, config)
        .then((response) => {
            let botResponse = '';

            if (response.data.vulnerabilities.length > 0) {
                botResponse += "**" + response.data.vulnerabilities[0].cve.id + "**\n";
                botResponse += "Fecha: " + moment(response.data.vulnerabilities[0].cve.published).format("DD-MM-YYYY HH:mm:ss") + "\n";
                botResponse += "Estado: " + response.data.vulnerabilities[0].cve.vulnStatus + "\n\n";

                if (!isEmpty(response.data.vulnerabilities[0].cve.metrics)) {
                    const score = response.data.vulnerabilities[0].cve.metrics.cvssMetricV31[0].cvssData.baseScore;

                    botResponse += "PuntuaciÃ³n: ";

                    if (score >= 8){
                        botResponse += "```diff\n-" + score + "```\n";
                    } else {
                        botResponse += score + "\n";
                    }

                    const attackComplexity = response.data.vulnerabilities[0].cve.metrics.cvssMetricV31[0].cvssData.attackComplexity;

                    switch (attackComplexity) {
                        case 'LOW':
                            botResponse += "Complejidad de ataque: *BAJA*. \n\n";
                            break;
                        case 'MEDIUM':
                            botResponse += "Complejidad de ataque: *MEDIA*. \n\n";
                            break;
                        case 'HIGH':
                            botResponse += "Complejidad de ataque: *ALTA*. \n\n";
                            break;
                    }
                }

                if (!isEmpty(response.data.vulnerabilities[0].cve.weaknesses)) {
                    botResponse += "Debilidades: \nSource: " + response.data.vulnerabilities[0].cve.weaknesses[0].source + "\n";
                    botResponse += "Type: " + response.data.vulnerabilities[0].cve.weaknesses[0].type + "\n";
                    botResponse += "CWE: " + response.data.vulnerabilities[0].cve.weaknesses[0].description[0].value + "\n\n";
                }

                botResponse +=  response.data.vulnerabilities[0].cve.descriptions[1] != undefined
                    ? response.data.vulnerabilities[0].cve.descriptions[1].value + "\n\n" : response.data.vulnerabilities[0].cve.descriptions[0].value + "\n\n";

                botResponse +=  "Referencias: \n\n";
                for (const reference of response.data.vulnerabilities[0].cve.references) {
                    botResponse +=  reference.url + "\n";
                }
            } else {
                botResponse += 'No se ha encontrado el CVE indicado.';
            }

            return {
                content: botResponse
            };
        });
    return response;
};

ApiService.prototype.searchCve = async function(keyword){
    const month = moment().subtract(1, 'months').format('YYYY-MM-DDT00:00:00');
    const today = moment(new Date()).format('YYYY-MM-DDT00:00:00');

    const response = await axios.get(baseApi + '?keywordSearch=' + keyword + '&pubStartDate=' +
        month + '&pubEndDate=' + today, config)
        .then((response) => {
            let botResponse = '';

            let vulnerabilities = response.data.vulnerabilities;
            // Sorting of object by published date of vulnerability, and slice by 3 elements
            vulnerabilities = vulnerabilities.sort((a,b)=>
                a.published > b.published ? 1:-1
            ).sort((a,b)=> {
                if (a.published === b.published) {
                    return a.published - b.published;
                }
            }).slice(0,3);

            //Format the response of the discord bot
            for (const vulnerability of vulnerabilities) {
                botResponse += "ðŸ”“ **" + vulnerability.cve.id + '**\n';
                botResponse += "Fecha: " + moment(vulnerability.cve.published).format('DD-MM-YYYY HH:mm:ss') + "\n\n";
                let description = vulnerability.cve.descriptions[1] != undefined ?
                    vulnerability.cve.descriptions[1].value + "\n\n" : vulnerability.cve.descriptions[0].value + "\n\n";

                if (description.length > 500) {
                    description = shorten(description, 500) + '... \n\n';
                }
                botResponse += description;
            }

            if (botResponse.length > maxSizeMessage) {
                botResponse = shorten(botResponse, maxSizeMessage - 3) + '...';
            }

            return {
                content: botResponse
            };
        });
    return response;
};

module.exports = ApiService;